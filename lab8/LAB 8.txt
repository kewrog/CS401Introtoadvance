1.	I used Eclipse IDE for lab 8 in this there are three parts. I created a Java project as lab8 in that  I have created three packages part 1, part 2, and part 3.
2.	For part 1, I created three classes employee, SortedLinkedList, and main. Before that, I imported the shuffled emp.txt file is stored in the part 1 workspace. In the employee class - Constructor: public employee(int id, String name) - A constructor that takes an employee's ID and name as parameters and initializes the instance variables. Getters: Methods getId() and getName() allow other classes to retrieve the employee's ID and name since the fields are private. toString Method: Overrides the toString method to return a string representation of the employee object, including its ID and name.
3.	In the SortedLinkedList - A custom method that adds an employee object to the list in a sorted order based on the employee ID. If the list is empty or the employee's ID is greater than the last element's ID, it adds the employee at the end. Otherwise, it finds the correct position so that the list remains sorted. RemoveById Method: Removes an employee from the list by their ID. containsById Method: Checks if an employee with a specific ID exists in the list.
4.	By importing the required library in the main class the emp file can be read. Each line is split into parts, and a new employee object is created and added to a SortedLinkedList instance using the addSorted method. Error Handling: Catches and handles IOException for file reading errors and NumberFormatException for invalid employee ID formats.
5.	Then for part 3, I used another ascending listed emp.txt file as the same one we used in the last part will be here. Then for the CircularLinkedList Contains two Employee references, head and tail, which point to the beginning and end of the list, respectively. Initially, both are null.
6.	insert Method: Add a new Employee to the list. If the list is empty, both head and tail point to this new employee, and its next reference points to itself, forming a circular structure. If the list is not empty, the new employee is added after the current tail and before the head, maintaining the circular nature.
7.	display Method: Iterates through the circular linked list starting from the head, printing out each employee's ID and name until it reaches the head again. If the list is empty, it prints a message indicating so.
8.	deleteById Method: Removes an employee from the list by their ID. It handles four cases:
9.	The list is empty, in which case it does nothing.
10.	The employee to be deleted is the only element, making the list empty afterward.
11.	The employee to be deleted is at the head of the list, in which case the head (and tail. next) is moved to the next employee. The employee to be deleted is at the tail, where the tail is updated to the previous employee, and its next is set to head.
12.	The employee is in the middle of the list, in which case the previous. next reference is updated to skip the deleted employee.
13.	For the main class Serves as the entry point for the application.
14.	File Reading: Reads from a file named emp.txt, expecting each line to contain an employee ID and name separated by whitespace. It creates and inserts up to 8 new Employee objects into the CircularLinkedList. Catches any exceptions thrown during file reading or parsing and prints the stack trace. After inserting employees, it displays the list, deletes an employee with a specific ID (in this case, ID 3), and displays the list again to show the effect of the deletion.
15.	Now part 3, I don't know whether we need to add the numbers or use the emp.txt file. so I used the 4 ransom numbers to show the output of the code.
16.	In the Node class represents a node in the doubly linked list. Each node contains integer data, and two references, prev and next, pointing to the previous and next nodes in the list, respectively. Initializes a Node object with the provided data. The previous and next references are initialized to null, indicating that the node is not yet linked to any other node in the list.
17.	For the DoublyLinkedList Contains two Node references, head, and tail, which point to the beginning and end of the list, respectively. Initially, both are null. Adds a new element to the end of the list. If the list is empty (head is null), both head and tail point to the new node. Otherwise, the new node is appended to the end and the previous reference of the new node points to the former tail. Removes an element from the list by its data value. It iterates through the list to find the node with the matching data. If found, it adjusts the previous and next references of the neighboring nodes to exclude the current node from the list. It also handles cases where the node to be removed is at the head or tail of the list. Check if an element is in the list. It iterates through the list, returning true if a node with the specified data is found.
18.	In Min class serves as the entry point for the application.
19.	Instantiates a DoublyLinkedList.
20.	Adding Elements: Demonstrates adding elements to the list.
21.	Removing an Element: Demonstrates removing an element by its data value.
22.	Checking for Elements: Demonstrates checking whether specific elements are in the list.
23.	Display: Prints the list contents after each operation to show the current state of the list.
24.	 I exported the Jar file for these 3 packages I will add command below how I executed the output of the JAR file.
25.	Part 1: we using emp.txt file here so I directly run the command prompt in the directory of the file - PS C:\Users\hp\eclipse-workspace\lab8\src\part1> java -jar "C:\Users\hp\eclipse-workspace\lab8\src\part1\lab8TASK1.jar"
26.	Part 2- as the same way by using this command - PS C:\Users\hp\eclipse-workspace\lab8\src\part2> java -jar "C:\Users\hp\eclipse-workspace\lab8\src\part2\lab8TASK2.jar"
27.	Part 3- using this command - PS C:\Users\hp\eclipse-workspace\lab8\src\part3> java -jar "C:\Users\hp\eclipse-workspace\lab8\src\part3\lab8TASK3.jar".
